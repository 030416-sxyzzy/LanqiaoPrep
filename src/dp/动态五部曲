动态五部曲：
1.确定dp数组含义
2.递推公式
3.dp数组如何初始化
4.遍历顺序
5.打印dp数组

动态规划类题型：
1.动态规划基础
（1）斐波那契数列
（2）爬楼梯
dp[i]是指爬i阶台阶，有dp[i]种方法
一个严谨的思考过程，应该是初始化dp[1] = 1，dp[2] = 2，然后i从3开始遍历，代码如下：
dp[1] = 1;
dp[2] = 2;
for (int i = 3; i <= n; i++) { // 注意i是从3开始的
    dp[i] = dp[i - 1] + dp[i - 2];
}

（3）使用最小花费爬楼梯
dp[0] = 0; // 默认第一步都是不花费体力的
dp[1] = 0;
        for (int i = 2; i <= cost.size(); i++) {
            dp[i] = min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2]);
        }
        
（4）不同路径
dp[i][j]定义 ：表示从（0 ，0）出发，到(i, j) 有dp[i][j]条不同的路径。
本题在初始化的时候需要点思考了，即：
dp[i][0]一定都是1，因为从(0, 0)的位置到(i, 0)的路径只有一条，那么dp[0][j]也同理。
所以初始化为：
for (int i = 0; i < m; i++) dp[i][0] = 1;
for (int j = 0; j < n; j++) dp[0][j] = 1;
这里已经不像之前做过的题目，随便赋个0就行的。
遍历顺序以及递推公式：
for (int i = 1; i < m; i++) {
    for (int j = 1; j < n; j++) {
        dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
    }
}

（5）不同路径II
dp[i][j]定义依然是：表示从（0 ，0）出发，到(i, j) 有dp[i][j]条不同的路径。
本题难点在于初始化，如果(i, 0) 这条边有了障碍之后，障碍之后（包括障碍）都是走不到的位置了，所以障碍之后的dp[i][0]应该还是初始值0。
for (int i = 0; i < m && obstacleGrid[i][0] == 0; i++) dp[i][0] = 1;
for (int j = 0; j < n && obstacleGrid[0][j] == 0; j++) dp[0][j] = 1;
递推公式只要考虑一下障碍，就不赋值了就可以了，如下：
for (int i = 1; i < m; i++) {
    for (int j = 1; j < n; j++) {
        if (obstacleGrid[i][j] == 1) continue;
        dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
    }
}

(6)整数拆分
dp[i]定义：分拆数字i，可以得到的最大乘积为dp[i]。
本题中dp[i]的初始化其实也很有考究，严格从dp[i]的定义来说，dp[0] dp[1] 就不应该初始化，也就是没有意义的数值。
拆分0和拆分1的最大乘积是多少？
这是无解的。
所以题解里我只初始化dp[2] = 1，从dp[i]的定义来说，拆分数字2，得到的最大乘积是1，这个没有任何异议！
dp[2] = 1;
遍历顺序以及递推公式：
for (int i = 3; i <= n ; i++) {
    for (int j = 1; j < i - 1; j++) {
        dp[i] = max(dp[i], max((i - j) * j, dp[i - j] * j));
    }
}

（7）不同的二叉搜索树
dp[i]定义 ：1到i为节点组成的二叉搜索树的个数为dp[i]。
递推公式：dp[i] += dp[j - 1] * dp[i - j]; ，j-1 为j为头结点左子树节点数量，i-j 为以j为头结点右子树节点数量
dp数组如何初始化：只需要初始化dp[0]就可以了，推导的基础，都是dp[0]。

2.背包问题
（1）背包理论基础01背包
dp数组含义：dp[i][j] 表示从下标为[0-i]的物品里任意取，放进容量为j的背包，价值总和最大是多少。
确定递推公式
这里在把基本信息给出来：
		重量	价值
物品0		1	15
物品1		3	20
物品2		4	30
对于递推公式，首先我们要明确有哪些方向可以推导出 dp[i][j]。
这里我们dp[1][4]的状态来举例：
求取 dp[1][4] 有两种情况：
放物品1
还是不放物品1
如果不放物品1， 那么背包的价值应该是 dp[0][4] 即 容量为4的背包，只放物品0的情况。
如果放物品1， 那么背包要先留出物品1的容量，目前容量是4，物品1 的容量（就是物品1的重量）为3，此时背包剩下容量为1。
容量为1，只考虑放物品0 的最大价值是 dp[0][1]，这个值我们之前就计算过。
所以 放物品1 的情况 = dp[0][1] + 物品1 的价值
两种情况，分别是放物品1 和 不放物品1，我们要取最大值（毕竟求的是最大价值）
dp[1][4] = max(dp[0][4], dp[0][1] + 物品1 的价值) 
以上过程，抽象化如下：
不放物品i：背包容量为j，里面不放物品i的最大价值是dp[i - 1][j]。
放物品i：背包空出物品i的容量后，背包容量为j - weight[i]，dp[i - 1][j - weight[i]] 为背包容量为j - weight[i]且不放物品i的最大价值，那么dp[i - 1][j - weight[i]] + value[i] （物品i的价值），就是背包放物品i得到的最大价值
递归公式： dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);
3.打家劫舍
4.股票问题
5.子序列问题
