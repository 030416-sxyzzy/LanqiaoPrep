(1)分割等和子集
只有确定了如下四点，才能把01背包问题套到本题上来：
背包的体积为sum / 2
背包要放入的商品（集合里的元素）重量为元素的数值，价值也为元素的数值
背包如何正好装满，说明找到了总和为 sum / 2 的子集。
背包中每一个元素是不可重复放入。
dp[j]定义：容量为j的背包所背的最大价值为dp[j],如果dp[j]==j,return true;
递推公式：dp[j]=Math.max(dp[j],dp[j-nums[i]]+nums[i]);
------------------------------------------------------------------------------
(2)最后一块石头的重量
解题思路：尽量让石头分成重量相同的两堆，相撞之后剩下的石头最小，这样就化解成01背包问题了
dp[j]定义：装满容量为j的背包的最大重量为dp[j]
代码：
int[] dp=new int[target+1];
for(int i=0;i<n;i++){
    for(int j=target;j>=stones[i];j--){
        dp[j]=Math.max(dp[j],dp[j-stones[i]]+stones[i]);
    }          
}
return sum-2*dp[target];
-------------------------------------------------------------------------------
(3)目标和
题意：示例：
输入：nums: [1, 1, 1, 1, 1], S: 3
输出：5
解释：
-1+1+1+1+1 = 3
+1-1+1+1+1 = 3
+1+1-1+1+1 = 3
+1+1+1-1+1 = 3
+1+1+1+1-1 = 3
一共有5种方法让最终目标和为3。
解题思路：left+right=sum;left-right=target;left=(sum+target)/2;//向下取整的情况是无解的
问题转化为装满容量为left的背包有多少种方法
dp[j]含义：装满容量为j的背包有dp[j]种方式
递推公式：dp[j]+=dp[j-nums[i]];
有哪些来源可以推出dp[j]呢？
只要搞到nums[i]，凑成dp[j]就有dp[j - nums[i]] 种方法。
例如：dp[j]，j 为5，
已经有一个1（nums[i]） 的话，有 dp[4]种方法 凑成 容量为5的背包。
已经有一个2（nums[i]） 的话，有 dp[3]种方法 凑成 容量为5的背包。
已经有一个3（nums[i]） 的话，有 dp[2]种方法 凑成 容量为5的背包
已经有一个4（nums[i]） 的话，有 dp[1]种方法 凑成 容量为5的背包
已经有一个5 （nums[i]）的话，有 dp[0]种方法 凑成 容量为5的背包
那么凑整dp[5]有多少方法呢，也就是把 所有的 dp[j - nums[i]] 累加起来。
初始化：dp[0]=0;
---------------------------------------------------------------------------------------------------
(4)474:一和零
输入：strs = ["10", "0001", "111001", "1", "0"], m = 5, n = 3
输出：4
解释：最多有 5 个 0 和 3 个 1 的最大子集是 {"10","0001","1","0"} ，因此答案是 4 。 
其他满足题意但较小的子集包括 {"0001","1"} 和 {"10","1","0"} 。{"111001"} 不满足题意，因为它含 4 个 1 ，大于 n 的值 3 。
解题思路：
本题是求装满这个背包最多有多少个物品
1.dp[i][j]定义：最多有i个0和j个1的strs的最大子集的大小为dp[i][j]。
2.确定递推公式：dp[i][j]=Math.max(dp[i][j],dp[i-x][j-y]+1)//取任意一个str,含有x个0，y个1;
3.初始化都为0
3.遍历顺序：先物品再倒序背包容量
for(String str:strs){//遍历物品
int x=0,y=0;
for(char c:str.toCharArray()){//计算0和1的个数
    if(c=='0'){
        x++;
    }else{
        y++;
    }
}
    for(int i=m;i>=x;i--){//遍历背包容量
        for(int j=n;j>=y;j--){
            dp[i][j]=Math.max(dp[i][j],dp[i-x][j-y]+1);
        }
    }
}





