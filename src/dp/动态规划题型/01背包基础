1.二维数组
(1)定义dp[i][j]:从[0,i]中取任意物品放进容量为j的背包中所产生的最大价值为dp[i][j]
(2)确定递推公式：dp[i][j] = Math.max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);表示放物品和不放物品
(3)初始化：当j为0，dp[i][0]=0;当i=0,j<weight[i]时,dp[i][j]=0;
写出代码：
//物品0初始化
for (int j = weight[0]; j <= bagweight; j++) {
	            dp[0][j] = value[0];
	        }
//从物品1开始遍历
for (int i = 1; i < n; i++) {//从物品1开始遍历
    for (int j = 0; j <= bagweight; j++) {
        if (j < weight[i]) {//背包容量比物品容量小
            dp[i][j] = dp[i - 1][j];//拷贝上层数值
        } else {
            dp[i][j] = Math.max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);
        }
    }
}
(4)遍历顺序：可以先背包再物品，也可以先物品再背包，因为dp[i][j]所需要的数据就是正上方或者左上角，不影响dp[i][j]的推导。
---------------------------------------------------------------------------------------------------
2.一维滚动数组
(1)定义：将上一层的值直接拷贝到当前层，再用当前层的值覆盖上一层的值。dp[j]表示容量为j的背包所背物品的价值最大为dp[j].
(2)确定递推公式：dp[j] = Math.max(dp[j], dp[j - weight[i]] + values[i]);
(3)初始化：dp[0]=0,dp[j]=0,不用初始化;
写出代码：
// 创建一个动态规划数组 dp，初始值为 0
int[] dp = new int[N + 1];

// 外层循环遍历每个类型的物品
for (int i = 0; i < M; i++) {
    // 内层循环从 N 空间逐渐减少到当前物品所占容量
    for (int j = N; j >= weight[i]; j--) {//当物品容量超过背包容量了，不需要更新，直接将上层的数值拷贝下来
        // 考虑当前物品选择和不选择的情况，选择最大值
        dp[j] = Math.max(dp[j], dp[j - weight[i]] + values[i]);
    }
}
(4)遍历顺序：
1.为什么要倒序遍历？
因为正序遍历会覆盖掉左上角的旧值，而dp[j]的更新依赖于左上角的数据，只有倒序遍历才能拿到左上角的旧值。
2.可以先遍历背包再遍历物品吗？
不能，因为背包的倒序遍历，意味着计算时是从表格的最后一列开始填数据，而要填的数据依赖于左上角的数据，但是当前左上角还并没有数据。
你永远只在更新正上方的数据，相当于背包里只放入了一个物品。
所以必须先遍历物品再遍历背包，先写第一行，左边才能有数据。


















